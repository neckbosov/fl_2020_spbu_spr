# Спецификация языка

Программа - последовательность инструкций. Формальная грамматика:

PROGRAM -> SEQ*

SEQ -> (INSTRUCTION WS*)*

INSTRUCTION -> IF | ASSIGN | WHILE | READ | WRITE

(моноширинным шрифтом указываются реальные символы, обычным - нетерминалы)

Есть 5 типов инструкций:

- Условный переход. Записывается с помощью ключевого слова `if`, отделенное
  произвольным количеством пробелов, за которым в круглых
  скобках следует условие в виде выражения. Далее следует блок кода, выполняющийся если условие
  в скобках истинно. Перед блоком также может быть произвольное количество пробелов.

  Блок кода --- последовательность инструкций, заключенная в фигурные скобки, после
  открывающей и перед закрывающей может быть произвольное количество пробельных символов.

  Грамматика: BLOCK -> `{` WS* SEQ WS* `}`

  Также после этой закрывающей скобки может быть ключевое слово `else`, отделенное
  произвольным количеством пробелов, после которого через произвольное количество пробелов
  следует блок кода, который выполняется если условие ложно.

  Грамматика: IF -> `if` SPACE* `(`EXPR`)` SPACE* BLOCK (WS* `else` WS* BLOCK)

- Цикл `while`. Записывается с помощью ключевого слова \textit{while}, отделенное
  произвольным количеством пробелов,за которым в круглых
  скобках следует условие в виде выражения. Далее следует блок кода, выполняющийся пока условие
  в скобках истинно. Перед блоком также может быть произвольное количество пробелов.

  Грамматика: WHILE -> `while` SPACE* `(`EXPR`)` SPACE* BLOCK

- Присваивание. Записывается как идентификатор, затем произвольное количество пробелов, знак
  равенства, затем выражение, затем точка с запятой. Описание идентификаторов и выражения ниже.

  Грамматика: ASSIGN -> IDENT SPACE* `=` SPACE* EXPR`;`

- Чтение переменной. Записывается как `read`, затем в скобках пишется идентификатор, в
  конце точка с запятой.

  Грамматика: READ -> `read(`IDENT`);`

- Вывод значения выражения. Записывается как \textit{write}, затем в скобках выражение, в
  конце точка с запятой.

  Грамматика: WRITE -> `write(`EXPR`);`

Идентификатор начинается в буквы латинского алфавита или подчеркивания.
Далее следует произвольное количество букв. цифр и знаков нижнего подчеркивания.

Грамматика: IDENT -> ((`a`..`z`) | (`A`..`Z`) | `_` ) ((`a`..`z`) | (`A`..`Z`) | `_` | (`0`..`9`))*

Выражения конструируются из чисел, переменных (идентификаторов), скобок и операторов естественным образом. Применение двух и более унарных операторов подряд без скобок не допускается.

Приоритеты и ассоциативность операторов перечислены в таблице:

| Приоритет | Оператор                         | Арность  | Ассоциативность   |
| :-------- | :------------------------------- | :------- | :---------------- |
| Высший    | `^`                              | Бинарный | Правоассоциативна |
|           | `-`                              | Унарный  |                   |
|           | `*`, `/`                         | Бинарный | Левоассоциативна  |
|           | `+`, `-`                         | Бинарный | Левоассоциативна  |
|           | `==`, `/=`, `<=`, `<`, `>=`, `>` | Бинарный | Неассоциативна    |
|           | `!`                              | Унарный  |                   |
|           | `&&`                             | Бинарный | Правоассоциативна |
| Низший    | `||`                             | Бинарный | Правоассоциативна |

Формальная грамматика выражений:

EXPR -> OR_E

OR_E -> AND_E | AND_E `||` OR_E

AND_E -> NOT_E | NOT_E `&&` NOT_E

NOT_E -> NOT_OP? CMP_E

CMP_E -> SUM_E | SUM_E CMP_OP SUM_E

CMP_OP -> `==` | `!=` | `<=` | `>=` | `<` | `>`

SUM_E -> MUL_E | SUM_E SUM_OP MUL_E

SUM_OP -> `+` | `-`

MUL_E -> MINUS_E | MUL_E MUL_OP MINUS_E

MUL_OP -> `*` | `/`

MINUS_E -> `-`? POW_E

POW_E -> TERM | TERM `^` POW_E

TERM -> NUM | IDENT |`(`EXPR`)`

NUM -> `0` | (`1`..`9`) (`0`..`9`)*
